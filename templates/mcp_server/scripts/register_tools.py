#!/usr/bin/env python3
"""
Tool Registration Script for MCP Server

This script discovers and registers all tools in the mcp_server.tools package.
It should be run whenever new tools are added to the package.
"""

import importlib
import pkgutil
import sys
from pathlib import Path
from typing import Any, Dict, List

# Add the project root to the Python path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))


def discover_tool_modules() -> List[str]:
    """Discover all tool modules in the mcp_server.tools package."""
    tools_pkg = "mcp_server.tools"
    tools_path = project_root / "src" / "mcp_server" / "tools"

    if not tools_path.exists():
        print(f"Error: Tools directory not found at {tools_path}")
        return []

    # Import the tools package
    try:
        tools_pkg = importlib.import_module(tools_pkg)
    except ImportError as e:
        print(f"Error importing {tools_pkg}: {e}")
        return []

    # Find all modules in the tools package
    modules = []
    for _, module_name, is_pkg in pkgutil.iter_modules([str(tools_path)]):
        if module_name == "__init__" or module_name.startswith("_"):
            continue
        modules.append(f"{tools_pkg.__name__}.{module_name}")

    return modules


def validate_tool(tool_func: Any) -> bool:
    """Validate that a tool function has the required attributes."""
    if not callable(tool_func):
        return False

    # Check for required attributes
    required_attrs = ["name", "description", "parameters"]
    for attr in required_attrs:
        if not hasattr(tool_func, attr):
            print(
                f"  Warning: Tool {getattr(tool_func, '__name__', 'unnamed')} is missing required attribute: {attr}"
            )
            return False

    return True


def register_tools() -> Dict[str, Any]:
    """Discover and register all tools in the tools package."""
    print("Discovering tools...")
    modules = discover_tool_modules()

    if not modules:
        print("No tool modules found.")
        return {}

    print(f"Found {len(modules)} tool modules:")
    for module_name in modules:
        print(f"  - {module_name}")

    # Import all tool modules
    tools = {}
    for module_name in modules:
        try:
            module = importlib.import_module(module_name)
            print(f"\nProcessing module: {module_name}")

            # Find all tools in the module
            for name, obj in module.__dict__.items():
                # Look for functions with the @tool decorator
                if hasattr(obj, "__wrapped__") and hasattr(obj, "name"):
                    if validate_tool(obj):
                        tools[obj.name] = obj
                        print(f"  Registered tool: {obj.name} ({obj.__name__})")
                    else:
                        print(f"  Skipping invalid tool: {name}")

        except Exception as e:
            print(f"Error processing module {module_name}: {e}")
            continue

    return tools


def generate_tool_registry(tools: Dict[str, Any]) -> str:
    """Generate a Python module with the tool registry."""
    imports = [
        "from typing import Dict, Any, Callable\n",
        "# This file is auto-generated by register_tools.py\n# Do not edit this file directly\n\n",
        "# Dictionary of all registered tools\n# Format: {'tool_name': tool_function}\nTOOL_REGISTRY: Dict[str, Callable] = {\n",
    ]

    # Add tool imports and registry entries
    tool_imports = set()
    tool_entries = []

    for tool_name, tool_func in tools.items():
        module_path = tool_func.__module__
        func_name = tool_func.__name__

        # Add import statement
        import_stmt = f"from {module_path} import {func_name}"
        tool_imports.add(import_stmt)

        # Add registry entry
        tool_entries.append(f'    "{tool_name}": {func_name},')

    # Combine all parts
    code_parts = []
    code_parts.extend(sorted(tool_imports))
    code_parts.append("")
    code_parts.extend(imports)
    code_parts.extend(tool_entries)
    code_parts.append("}\n")

    return "\n".join(code_parts)


def main():
    """Main entry point for the tool registration script."""
    # Discover and register tools
    tools = register_tools()

    if not tools:
        print("No tools found to register.")
        return 1

    # Generate the tool registry
    registry_code = generate_tool_registry(tools)

    # Write the registry to a file
    registry_path = project_root / "src" / "mcp_server" / "tool_registry.py"
    try:
        with open(registry_path, "w", encoding="utf-8") as f:
            f.write(registry_code)
        print(f"\nSuccessfully registered {len(tools)} tools in {registry_path}")
    except Exception as e:
        print(f"Error writing tool registry: {e}")
        return 1

    return 0


if __name__ == "__main__":
    sys.exit(main())
